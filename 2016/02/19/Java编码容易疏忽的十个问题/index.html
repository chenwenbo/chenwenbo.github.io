<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Java编码容易疏忽的十个问题 | 尔东陈</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java编码容易疏忽的十个问题</h1><a id="logo" href="/.">尔东陈</a><p class="description">但行好事，莫问前程。</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/time-line/"><i class="icon-archive"> time-line</i></a><a href="/about/"><i class="icon-about"> 关于</i></a><a href="/atom.xml"><i class="icon-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">Java编码容易疏忽的十个问题</h1><div class="post-meta">2016-02-19 | </div><div class="post-content"><p>在Java编码中，我们容易犯一些错误，也容易疏忽一些问题，因此笔者对日常编码中曾遇到的一些经典情形归纳整理成文，以共同探讨。</p>
<hr>
<h3 id="1-__u7EA0_u7ED3_u7684_u540C_u540D"><a href="#1-__u7EA0_u7ED3_u7684_u540C_u540D" class="headerlink" title="1. 纠结的同名"></a>1. 纠结的同名</h3><p><strong> 出现的问题 </strong></p>
<p>很多类的命名相同（例如：常见于异常、常量、日志等类），导致在import时，有时候张冠李戴，这种错误有时候很隐蔽。因为往往同名的类功能也类似，所以IDE不会提示warn。</p>
<p><strong> 解决方法 </strong></p>
<p>写完代码时，扫视下import部分，看看有没有不熟悉的。替换成正确导入后，要注意下注释是否也作相应修改。</p>
<p><strong> 得到的结论 </strong></p>
<p>命名尽量避开重复名，特别要避开与JDK中的类重名，否则容易导入错，同时存在大量重名类，在查找时，也需要更多的辨别时间。</p>
<hr>
<h3 id="2-__u60F3_u5F53_u7136_u7684API"><a href="#2-__u60F3_u5F53_u7136_u7684API" class="headerlink" title="2. 想当然的API"></a>2. 想当然的API</h3><p><strong> 出现的问题 </strong></p>
<p>有时候调用API时，会想当然的通过名字直接自信满满地调用，导致很惊讶的一些错误：</p>
<p>示例一：flag是true？<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">boolean flag</span> = Boolean.getBoolean(<span class="string">"true"</span>);</div></pre></td></tr></table></figure></p>
<p>可能老是false。</p>
<p>示例二：这是去年的今天吗（今年是2012年，不考虑闰年）？结果还是2012年：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Calendar </span><span class="keyword">calendar </span>= GregorianCalendar.getInstance()<span class="comment">;</span></div><div class="line"><span class="keyword">calendar.roll(Calendar.DAY_OF_YEAR, </span>-<span class="number">365</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>下面的才是去年<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">calendar</span><span class="selector-class">.add</span>(<span class="selector-tag">Calendar</span><span class="selector-class">.DAY_OF_YEAR</span>, <span class="selector-tag">-365</span>);</div></pre></td></tr></table></figure></p>
<p><strong> 解决方法 </strong></p>
<p>问自己几个问题，这个方法我很熟悉吗？有没有类似的API? 区别是什么？就示例一而言，需要区别的如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Boolean</span><span class="selector-class">.valueOf</span>(<span class="selector-tag">b</span>) <span class="selector-tag">VS</span> <span class="selector-tag">Boolean</span><span class="selector-class">.parseBoolean</span>(<span class="selector-tag">b</span>) <span class="selector-tag">VS</span> <span class="selector-tag">Boolean</span><span class="selector-class">.getBoolean</span>(<span class="selector-tag">b</span>);</div></pre></td></tr></table></figure></p>
<p><strong> 得到的结论 </strong></p>
<p>名字起的更详细点，注释更清楚点，不要不经了解、测试就想当然的用一些API，如果时间有限，用自己最为熟悉的API。</p>
<hr>
<h3 id="3-__u6709_u65F6_u5019_u6EA2_u51FA_u5E76_u4E0D_u96BE"><a href="#3-__u6709_u65F6_u5019_u6EA2_u51FA_u5E76_u4E0D_u96BE" class="headerlink" title="3. 有时候溢出并不难"></a>3. 有时候溢出并不难</h3><p><strong> 出现的问题 </strong></p>
<p>有时候溢出并不难，虽然不常复现：</p>
<p>示例一：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> x=Integer.MAX_VALUE+<span class="number">1</span>;</div><div class="line">System.out.<span class="built_in">println</span>(x);</div></pre></td></tr></table></figure></p>
<p>x是多少？竟然是-2147483648，明明加上1之后还是long的范围。类似的经常出现在时间计算：</p>
<p>数字1×数字2×数字3…<br>示例二：</p>
<p>在检查是否为正数的参数校验中，为了避免重载，选用参数number, 于是下面代码结果小于0，也是因为溢出导致：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Number i=Long.MAX_VALUE<span class="comment">;</span></div><div class="line">System.out.println(i.intValue()&gt;<span class="number">0</span>)<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p><strong> 解决方法 </strong></p>
<p>让第一个操作数是long型，例如加上L或者l（不建议小写字母l，因为和数字1太相似了）；<br>不确定时，还是使用重载吧，即使用doubleValue()，当参数是BigDecimal参数时，也不能<strong> 解决方法 </strong>问题。<br><strong> 得到的结论 </strong></p>
<p>对数字运用要保持敏感：涉及数字计算就要考虑溢出；涉及除法就要考虑被除数是0；实在容纳不下了可以考虑BigDecimal之类。</p>
<hr>
<h3 id="4-__u65E5_u5FD7_u8DD1_u54EA_u4E86_uFF1F"><a href="#4-__u65E5_u5FD7_u8DD1_u54EA_u4E86_uFF1F" class="headerlink" title="4. 日志跑哪了？"></a>4. 日志跑哪了？</h3><p><strong> 出现的问题 </strong></p>
<p>有时候觉得log都打了，怎么找不到？</p>
<p>示例一：没有stack trace！<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#125; catch (Exception <span class="keyword">ex</span>) &#123;</div><div class="line">   <span class="keyword">log</span>.<span class="keyword">error</span>(<span class="keyword">ex</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例二：找不到log！<br><figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#125; <span class="selector-tag">catch</span> (ConfigurationException e) &#123;</div><div class="line">    <span class="selector-tag">e</span><span class="selector-class">.printStackTrace</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong> 解决方法 </strong></p>
<p>替换成log.error(ex.getMessage(),ex);<br>换成普通的log4j吧，而不是System.out。<br><strong> 得到的结论 </strong></p>
<p>API定义应该避免让人犯错，如果多加个重载的log.error(Exception)自然没有错误发生</p>
<h2 id="u5728_u4EA7_u54C1_u4EE3_u7801_u4E2D_uFF0C_u4F7F_u7528_u7684_u4E00_u4E9B_u65B9_u6CD5_u8981_u8003_u8651_u662F_u5426_u6709_u6548_uFF0C_u4F7F_u7528e-printStackTrace_28_29_u8981_u60F3_u4E0B_u7EC8_u7AEF_28Console_29_u5728_u54EA_u3002"><a href="#u5728_u4EA7_u54C1_u4EE3_u7801_u4E2D_uFF0C_u4F7F_u7528_u7684_u4E00_u4E9B_u65B9_u6CD5_u8981_u8003_u8651_u662F_u5426_u6709_u6548_uFF0C_u4F7F_u7528e-printStackTrace_28_29_u8981_u60F3_u4E0B_u7EC8_u7AEF_28Console_29_u5728_u54EA_u3002" class="headerlink" title="在产品代码中，使用的一些方法要考虑是否有效，使用e.printStackTrace()要想下终端(Console)在哪。"></a>在产品代码中，使用的一些方法要考虑是否有效，使用e.printStackTrace()要想下终端(Console)在哪。</h2><h3 id="5-__u9057_u5FD8_u7684volatile"><a href="#5-__u9057_u5FD8_u7684volatile" class="headerlink" title="5. 遗忘的volatile"></a>5. 遗忘的volatile</h3><p><strong> 出现的问题 </strong></p>
<p>在DCL模式中，总是忘记加一个Volatile。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">private<span class="keyword"> static</span> CacheImpl instance;  //lose volatile<span class="keyword"></span></div><div class="line">public<span class="keyword"> static</span> CacheImpl getInstance() &#123;</div><div class="line">   <span class="built_in"> if </span>(instance == null) &#123;</div><div class="line">        synchronized (CacheImpl.class) &#123;</div><div class="line">           <span class="built_in"> if </span>(instance == null) &#123;</div><div class="line">               <span class="built_in"> instance </span>=<span class="built_in"> new </span>CacheImpl (); </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="built_in"> return </span>instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong> 解决方法 </strong></p>
<p>毋庸置疑，加上一个吧，synchronized 锁的是一块代码（整个方法或某个代码块），保证的是这”块“代码的可见性及原子性，但是instance == null第一次判断时不再范围内的。所以可能读出的是过期的null。</p>
<p><strong> 得到的结论 </strong></p>
<p>我们总是觉得某些低概率的事件很难发生，例如某个时间并发的可能性、某个异常抛出的可能性，所以不加控制，但是如果可以，还是按照前人的“最佳实践”来写代码吧。至少不用过多解释为啥另辟蹊径。</p>
<hr>
<h3 id="6-__u4E0D_u8981_u5F71_u54CD_u5F7C_u6B64"><a href="#6-__u4E0D_u8981_u5F71_u54CD_u5F7C_u6B64" class="headerlink" title="6. 不要影响彼此"></a>6. 不要影响彼此</h3><p><strong> 出现的问题 </strong></p>
<p>在释放多个IO资源时，都会抛出IOException ，于是可能为了省事如此写：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static void inputToOutput(InputStream is, OutputStream os,</div><div class="line">           <span class="keyword">boolean </span>isClose) throws IOException &#123;</div><div class="line">    <span class="keyword">BufferedInputStream </span><span class="keyword">bis </span>= new <span class="keyword">BufferedInputStream(is, </span><span class="number">1024</span>)<span class="comment">;</span></div><div class="line">    <span class="keyword">BufferedOutputStream </span><span class="keyword">bos </span>= new <span class="keyword">BufferedOutputStream(os, </span><span class="number">1024</span>)<span class="comment">;  </span></div><div class="line">    ….</div><div class="line">    if (isClose) &#123;</div><div class="line">       <span class="keyword">bos.close();</span></div><div class="line">       <span class="keyword">bis.close();</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>假设bos关闭失败，bis还能关闭吗？当然不能！</p>
<p><strong> 解决方法 </strong>办法</p>
<p>虽然抛出的是同一个异常，但是还是各自捕获各的为好。否则第一个失败，后一个面就没有机会去释放资源了。</p>
<p><strong> 得到的结论 </strong></p>
<p>代码/模块之间可能存在依赖，要充分识别对相互的依赖。</p>
<hr>
<h3 id="7-__u7528_u65AD_u8A00_u53D6_u4EE3_u53C2_u6570_u6821_u9A8C"><a href="#7-__u7528_u65AD_u8A00_u53D6_u4EE3_u53C2_u6570_u6821_u9A8C" class="headerlink" title="7. 用断言取代参数校验"></a>7. 用断言取代参数校验</h3><p><strong> 出现的问题 </strong></p>
<p>如题所提，作为防御式编程常用的方式：断言，写在产品代码中做参数校验等。例如：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(List&lt; Event&gt; eventList)</span>  </span>&#123;</div><div class="line">    <span class="keyword">assert</span> eventList != <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong> 解决方法 </strong></p>
<p>换成正常的统一的参数校验方法。因为断言默认是关闭的，所以起不起作用完全在于配置，如果采用默认配置，经历了eventList != null结果还没有起到作用，徒劳无功。</p>
<p><strong> 得到的结论 </strong></p>
<p>有的时候，代码起不起作用，不仅在于用例，还在于配置，例如断言是否启用、log级别等，要结合真实环境做有用编码。</p>
<hr>
<h3 id="8-__u7528_u6237_u8BA4_u77E5_u8D1F_u62C5_u6709_u65F6_u5019_u5F88_u91CD"><a href="#8-__u7528_u6237_u8BA4_u77E5_u8D1F_u62C5_u6709_u65F6_u5019_u5F88_u91CD" class="headerlink" title="8. 用户认知负担有时候很重"></a>8. 用户认知负担有时候很重</h3><p><strong> 出现的问题 </strong></p>
<p>先来比较三组例子，看看那些看着更顺畅？</p>
<p>示例一：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> caller(<span class="keyword">int</span> a, <span class="keyword">String</span> b, <span class="keyword">float</span> c, <span class="keyword">String</span> d) &#123;</div><div class="line">    methodOne(d, z, b);</div><div class="line">    methodTwo(b, c, d);</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> methodOne(<span class="keyword">String</span> d, <span class="keyword">float</span> z, <span class="keyword">String</span> b)  </div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> methodTwo(<span class="keyword">String</span> b, <span class="keyword">float</span> c, <span class="keyword">String</span> d)</div></pre></td></tr></table></figure></p>
<p>示例二：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="built_in">remove</span>(<span class="keyword">String</span> key, <span class="keyword">long</span> timeout) &#123;</div><div class="line">             Future&lt; Boolean&gt; future = memcachedClient.<span class="keyword">delete</span>(key);</div><div class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="keyword">delete</span>(<span class="keyword">String</span> key, <span class="keyword">long</span> timeout) &#123;</div><div class="line">             Future&lt; Boolean&gt; future = memcachedClient.<span class="keyword">delete</span>(key);</div></pre></td></tr></table></figure></p>
<p>示例三：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> getDigest(<span class="keyword">String</span> filePath, DigestAlgorithm algorithm)</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> getDigest(<span class="keyword">String</span> filePath, DigestAlgorithm digestAlgorithm)</div></pre></td></tr></table></figure></p>
<p><strong> 解决方法 </strong></p>
<p>保持参数传递顺序；<br>remove变成了delete，显得突兀了点， 统一表达更好；<br>保持表达，少缩写也会看起来流畅点。<br><strong> 得到的结论 </strong></p>
<p>在编码过程中，不管是参数的顺序还是命名都尽量统一，这样用户的认知负担会很少，不要要用户容易犯错或迷惑。例如用枚举代替string从而不让用户迷惑到底传什么string, 诸如此类。</p>
<hr>
<h3 id="9-__u5FFD_u89C6_u65E5_u5FD7_u8BB0_u5F55_u65F6_u673A_u3001_u7EA7_u522B"><a href="#9-__u5FFD_u89C6_u65E5_u5FD7_u8BB0_u5F55_u65F6_u673A_u3001_u7EA7_u522B" class="headerlink" title="9. 忽视日志记录时机、级别"></a>9. 忽视日志记录时机、级别</h3><p><strong> 出现的问题 </strong></p>
<p>存在下面两则示例：</p>
<p>示例一：该不该记录日志？<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">catch</span> (SocketException e)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">LOG</span>.<span class="built_in">error</span>(<span class="string">"server error"</span>, e);</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConnectionException(e.getMessage(), e);</div><div class="line">&#125;  </div><div class="line">``` </div><div class="line">示例二：记什么级别日志？</div><div class="line"></div><div class="line">在用户登录系统中，每次失败登录：</div></pre></td></tr></table></figure></p>
<p>LOG.warn(“Failed to login by “+username+”);<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="bullet">** </span>解决方法 **</div><div class="line"></div><div class="line">移除日志记录：在遇到需要re-throw的异常时，如果每个人都按照先记录后throw的方式去处理，那么对一个错误会记录太多的日志，所以不推荐如此做；但是如果re-throw出去的exception没有带完整的trace( 即cause)，那么最好还是记录下。</div><div class="line">如果恶意登录，那系统内部会出现太多WARN，从而让管理员误以为是代码错误。可以反馈用户以错误，但是不要记录用户错误的行为，除非想达到控制的目的。</div><div class="line"><span class="bullet">** </span>得到的结论 **</div><div class="line"></div><div class="line">日志改不改记？记成什么级别？如何记？这些都是问题，一定要根据具体情况，需要考虑：</div><div class="line"></div><div class="line">是用户行为错误还是代码错误？</div><div class="line"><span class="section">记录下来的日志，能否能给别人在不造成过多的干扰前提下提供有用的信息以快速定位问题。</span></div><div class="line">---</div><div class="line">### 10. 忘设初始容量</div><div class="line"></div><div class="line"><span class="bullet">** </span>出现的问题 **</div><div class="line"></div><div class="line">在JAVA中，我们常用Collection中的Map做Cache,但是我们经常会遗忘设置初始容量。</div></pre></td></tr></table></figure></p>
<p>cache = new LRULinkedHashMap&lt; K, V&gt;(maxCapacity);<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">** 解决方法 **</div><div class="line"></div><div class="line">初始容量的影响有多大？拿LinkedHashMap来说，初始容量如果不设置默认是<span class="number">16</span>，超过<span class="number">16</span>×LOAD_FACTOR,会resize(<span class="number">2</span> * table.length),扩大<span class="number">2</span>倍：采用 Entry[] newTable = new Entry[newCapacity]; transfer(newTable)，即整个数组Copy， 那么对于一个需要做大容量CACHE来说，从<span class="number">16</span>变成一个很大的数量，需要做多少次数组复制可想而知。如果初始容量就设置很大，自然会减少resize, 不过可能会担心，初始容量设置很大时，没有Cache内容仍然会占用过大体积。其实可以参考以下表格简单计算下, 初始时还没有cache内容, 每个对象仅仅是<span class="number">4</span>字节引用而已。</div></pre></td></tr></table></figure></p>
<p>memory for reference fields (4 bytes each);<br>memory for primitive fields<br>Java type    Bytes required<br>boolean    1<br>byte<br>char    2<br>short<br>int    4<br>float<br>long    8<br>double<br>```<br><strong> 得到的结论 </strong></p>
<p>不仅是map, 还有stringBuffer等，都有容量resize的过程，如果数据量很大，就不能忽视初始容量可以考虑设置下，否则不仅有频繁的 resize还容易浪费容量。</p>
<p>在Java编程中，除了上面枚举的一些容易忽视的问题，日常实践中还存在很多。相信通过不断的总结和努力，可以将我们的程序完美呈现给读者。</p>
<hr>
<blockquote>
<p><a href="http://www.infoq.com/cn/articles/10-java-questions-easy-to-ignore" target="_blank" rel="external">相关链接</a></p>
</blockquote>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/02/19/如何快速掌握一门新技术-语言-框架/" class="pre"><i class="icon-previous">如何快速掌握一门新技术/语言/框架</i></a><a href="/2016/02/19/业务系统如何记录日志/" class="next">业务系统如何记录日志<i class="icon-next"></i></a></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search" class="search-form-input"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/JAVA/" style="font-size: 15px;">JAVA</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/习惯养成计划第一期/" style="font-size: 15px;">习惯养成计划第一期</a> <a href="/tags/java/" style="font-size: 15px;">java</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/10/30/git-rebase/">git_rebase</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/06/Java-Equals-HashCode/">Java hashCode & equals</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/29/Java类和对象的初始化/">Java类和对象的初始化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/Java成员变量和局部变量/">Java成员变量和局部变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/13/web-exception-handle/">web_exception_handle</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/07/Spring-bean-load/">Spring_bean_load</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/05/zsh-feature/">zsh_feature</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/04/Java-Volatile/">Java_Volatile</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/04/Java基本数据类型/">Java基本数据类型</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/31/Java集合线程安全/">Java集合线程安全</a></li></ul></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://weibo.com/2316099870" title="微博" target="_blank">微博</a><ul></ul><a href="https://www.zhihu.com/people/chen-wen-bo-21" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://github.com/chenwenbo" title="github" target="_blank">github</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">尔东陈.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script src="/js/jquery.min.js"></script>
<script src="/js/totop.js"></script><script src="/js/fancybox.pack.js"></script>
<script src="/js/jquery.fancybox.js"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"></div></body></html>